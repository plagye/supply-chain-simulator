# Supply Chain Simulator

A discrete-event supply chain simulation for **SkyForge Dynamics**, a fictional manufacturer of commercial drones. The simulator models demand, production (BOM and jobs), procurement, shipments, invoicing, and delivery across a single plant, multiple distribution centers, and several suppliers and customers. It can run as a one-shot simulation (fixed ticks) or as a **continuous service** with a **live read-only HTTP API** for dashboards and integrations.

---

## Business Scenario

**SkyForge** produces **10 drone models** (D-101 through D-303) at one **plant** (FAC-001, Chicago). Products share **10 common parts** (P-001..P-010) sourced from **4 suppliers** in China, Germany, and the USA. Finished goods are shipped to **4 distribution centers** (NA: Detroit, Dallas; EMEA: Rotterdam; APAC: Singapore), and **15 customers** across segments (Retail, Logistics, Agriculture, Government) place orders that are fulfilled from inventory or backordered.

- **Demand:** Random sales orders by product; higher probability during business hours; optional bulk orders and promotions.
- **Production:** Jobs consume parts per BOM; duration and lead times are configurable; quality reject rates apply.
- **Procurement:** Purchase orders to suppliers with base lead times; partial shipments and quality rejects.
- **Delivery:** Loads move from plant to DCs by **location code** (e.g. USA_CHI → USA_DET); delivery events and optional transit delay.
- **Finance:** Invoicing and payments with configurable terms and late-payment probability.
- **Planning:** Optional demand forecast, S&OP snapshots, and cost drift / seasonality for realism.

The **live API** (when running in service mode) exposes current status, inventory (parts and products), backorders, and deliveries so external systems can “call and get values” without building a UI in this repo.

---

## Key Parameters of the Situation

| Dimension | Count / Scope | Details |
|-----------|----------------|---------|
| **Parts** | 10 | P-001..P-010: Frame-Light/Heavy, Motor-Std/Pro, Propeller-Set, Battery-5Ah/10Ah, Flight-Controller, Nav-GPS, Payload-Interface. See `data/parts.json`. |
| **Products** | 10 | D-101 Sparrow-S1, D-102 Sparrow-Pro, D-103 Falcon-X, D-201 Courier-M, D-202 Courier-L, D-203 Surveyor-300, D-204 Surveyor-500, D-301 Titan-Hauler, D-302 Agri-Sprayer, D-303 Sky-Crane. Generated by `scripts/generate_products.py` → `data/products.json`. |
| **BOM** | Multi-product | Each product uses a subset of the 10 parts; structure in `data/bom.json` as `{ "products": { "D-101": { "bom": [...] }, ... } }`. |
| **Suppliers** | 4 | SUP-001 VoltStream Tech (China), SUP-002 CarbonFiber Works (Germany), SUP-003 LogicCore Systems (USA), SUP-004 OmniMount Solutions (USA). Reliability, risk, and price multipliers in `data/suppliers.json`. |
| **Facilities** | 5 | FAC-001 SkyForge HQ (plant, Chicago, `USA_CHI`); dist_na_01 (Detroit, `USA_DET`), dist_na_02 (Dallas, `USA_DAL`), dist_emea_01 (Rotterdam, `NLD_RTM`), dist_apac_01 (Singapore, `SGP_SIN`). |
| **Routes** | Inbound + outbound | Inbound: plant → suppliers (China, Germany, USA). Outbound: plant → each DC by `origin_location_code` / `destination_location_code`. |
| **Customers** | 15 | 4 segments; each has `destination_facility_id` and `delivery_location_code` for code-based delivery. |

All IDs (parts, products, facilities, routes, customers) are fixed by the generators so the engine and API are deterministic for a given seed.

---

## Overview

The simulator generates realistic supply chain events, including:

- Customer demand with business-hour patterns, bulk orders, and **seasonality** (monthly, day-of-week, period-end)
- Production scheduling with BOM consumption and configurable job duration
- Procurement with supplier reliability and lead times; partial shipments and quality rejects
- Inventory management with automatic reorder points
- Backorders and split shipments when demand exceeds supply
- Cost drift over time and supplier pricing
- Invoicing and payments with configurable terms
- Loads and delivery events (plant → DC by location code)
- Demand forecasts and S&OP snapshots
- Promotional demand spikes
- **Black swan events** (major disruptions when generating 3-year history only)

---

## Simulation Engine Parameters

Controlled via `config.json` under `simulate.engine` / `run-service.engine` (and `all.engine`). Key groups:

| Area | Parameters | Meaning |
|------|------------|---------|
| **Demand** | `demand_probability_base`, `demand_probability_business_hours`, `business_hours_start`/`_end` | Base and business-hour order probabilities (per tick). |
| | `bulk_order_probability`, `bulk_order_qty_min`/`_max`, `normal_order_qty_min`/`_max` | Bulk vs normal order sizes. |
| **Production** | `production_duration_hours_min`/`_max` | Job duration range. |
| **Procurement** | `base_lead_time_hours_min`/`_max` | Supplier lead time range. |
| | `partial_shipment_probability`, `partial_shipment_min_pct`/`_max_pct` | Partial deliveries. |
| | `quality_reject_rate_min`/`_max` | Incoming quality rejection. |
| **Cost** | `cost_drift_enabled`, `cost_drift_daily_pct`, `cost_drift_max_pct` | Daily cost drift cap. |
| **Seasonality** | `seasonality_enabled`, `demand_seasonality_strength`, `supplier_seasonality_strength` | Demand and supply seasonality. |
| **Invoicing** | `invoice_enabled`, `invoice_payment_days_min`/`_max`, `payment_late_probability`, `payment_late_days_extra` | Payment terms and late payments. |
| **Pricing** | `default_unit_price` | Default product price (e.g. 1250). |
| **Planning** | `forecast_enabled`, `forecast_horizon_days`, `forecast_window_days`, `requirements_lead_time_days` | Demand forecast and planning horizon. |
| | `sop_enabled`, `sop_frequency` | S&OP snapshot frequency (e.g. monthly). |
| **Promo** | `promo_enabled`, `promo_probability`, `promo_duration_days`, `promo_demand_multiplier_min`/`_max` | Promotional demand spikes. |
| **Delivery** | `delivery_enabled`, `delivery_transit_delay_max_hours` | Delivery events and max transit delay. |

Exact keys and defaults are in `config.json`; the engine reads the whole `engine` block.

---

## Quick Start

```bash
pip install -r requirements.txt
python main.py generate
python main.py simulate --ticks 720
```

Events are written to date-partitioned JSONL under `data/events/` (e.g. `YYYY-MM-DD.jsonl`). All event lines are valid JSON (one object per line).

---

## Project Layout

```
supply-chain-simulator/
├── main.py                 # CLI entry point
├── config.json             # Configuration defaults
├── requirements.txt        # Python dependencies
├── .env.example            # Database credentials template
├── scripts/
│   ├── world_engine.py     # Core simulation engine
│   ├── api.py             # Live HTTP API (FastAPI)
│   └── generate_*.py       # Data generator scripts
└── data/
    ├── *.json              # Master data and state files
    └── events/             # Event JSONL (date-partitioned or history.jsonl)
```

---

## Commands

| Command | Description |
|--------|-------------|
| `python main.py generate [--seed 42]` | Generate all master data (suppliers, parts, products, BOM, facilities, routes, customers, inventory, production_schedule). |
| `python main.py simulate [--ticks 720] [--seed 42]` | Run simulation for a fixed number of hourly ticks. |
| `python main.py all [--ticks 720] [--seed 42]` | Generate then simulate. |
| `python main.py generate-history --years 3 [--seed 42]` | Generate 1–3 years of history to `data/events/history.jsonl`. |
| `python main.py run-service [--tick-interval 5] [--resume \| --fresh]` | Run as continuous service (state in PostgreSQL optional); **live API** available when enabled in config. |

**Options:** `generate` and `simulate`/`all` accept `--seed`. `simulate`/`all` accept `--ticks` (hours). `generate-history` requires `--years` (1, 2, or 3); black swan events run only for 3 years. `run-service` uses `--resume` (default) or `--fresh` and `--tick-interval` (seconds between ticks).

---

## Live API (run-service only)

When `run-service` is used, a read-only HTTP API serves current simulation state so you can **call and get values** (e.g. for a dashboard or integration). No UI is built in this repo.

- **Base URL:** `http://<host>:<port>` (default from config: `http://127.0.0.1:8010`).
- **Binding:** In `config.json` under `run-service`, set `api_host` to `0.0.0.0` to listen on all interfaces (e.g. on an Ubuntu server); then call the API using the server’s IP, e.g. `http://<server-ip>:8010/status`.

### Endpoints

| Method | Path | Description |
|--------|------|-------------|
| GET | `/status` | Simulation status: `current_time`, `tick_count`, `running`. |
| GET | `/inventory` | All current inventory (parts + products). |
| GET | `/inventory/parts` | Parts only (P-001..P-010). |
| GET | `/inventory/products` | Finished products only (D-101..D-303). |
| GET | `/inventory/{id}` | Single item by part_id or product_id (404 if missing). |
| GET | `/backorders` | Pending backorders. |
| GET | `/deliveries` | Pending deliveries (loads in transit). |

### Example

```bash
curl http://127.0.0.1:8010/status
curl http://127.0.0.1:8010/inventory
curl http://127.0.0.1:8010/inventory/parts
curl http://127.0.0.1:8010/backorders
curl http://127.0.0.1:8010/deliveries
```

---

## Config

- **run-service:** `tick_interval`, `seed`, `api_host` (default `127.0.0.1`), `api_port` (default `8010`), `api_enabled` (default `true`).
- **simulate / run-service / all:** Full `engine` block for demand, production, suppliers, invoicing, forecast, S&OP, promo, delivery, cost_drift, seasonality. See `config.json`.

---

## Output Files

- **Master data:** `data/suppliers.json`, `parts.json`, `products.json` (from `generate_products.py`), `bom.json`, `customers.json`, `facilities.json`, `routes.json`, `inventory.json`, `production_schedule.json`.
- **Events:** `simulate` and `run-service` write date-partitioned JSONL under `data/events/` (e.g. `YYYY-MM-DD.jsonl`). `generate-history` writes a single file `data/events/history.jsonl`. **Every line is valid JSON** (one object per line). Event payloads use the 10 product IDs (D-101..D-303) and 10 part IDs (P-001..P-010).

### Event Types

| Event | Description | Key Payload Fields |
|-------|-------------|-------------------|
| `SalesOrderCreated` | Customer places order | `order_id`, `customer_id`, `product_id`, `qty` |
| `ShipmentCreated` | Order shipped in full | `order_id`, `product_id`, `qty`, `remaining_stock` |
| `PartialShipmentCreated` | Partial fulfillment | `order_id`, `qty_shipped`, `qty_backordered` |
| `BackorderCreated` | Order cannot be fulfilled | `order_id`, `qty_backordered`, `reason` |
| `BackorderFulfilled` | Backorder shipped | `order_id`, `qty_shipped`, `qty_still_pending` |
| `LoadCreated` | Load dispatched for delivery | `load_id`, `order_id`, `route_id`, `product_id`, `qty`, `weight_lbs`, `scheduled_delivery` |
| `DeliveryEvent` | Pickup or delivery at facility | `load_id`, `event_type` (Pickup/Delivery), `facility_id`, `actual_datetime` |
| `InvoiceCreated` | Invoice issued | `invoice_id`, `order_id`, `product_id`, `qty`, `amount`, `due_date` |
| `PaymentReceived` | Customer payment | `invoice_id`, `order_id`, `amount`, `paid_at`, `on_time` |
| `ProductionJobCreated` | New production job | `job_id`, `product_id`, `production_duration_hours` |
| `ProductionStarted` | Job begins | `job_id`, `expected_completion` |
| `ProductionCompleted` | Job finished | `job_id`, `new_qty_on_hand` |
| `PurchaseOrderCreated` | Parts ordered | `purchase_order_id`, `part_id`, `qty`, `unit_cost`, `eta` |
| `PurchaseOrderReceived` | Parts received | `purchase_order_id`, `qty_received`, `new_qty_on_hand` |
| `ReorderTriggered` | Auto-reorder | `part_id`, `qty_on_hand`, `reorder_point` |
| `DemandForecastCreated` | Demand forecast snapshot | `product_id`, `forecast_qty`, `horizon_days` |
| `SOPSnapshotCreated` | S&OP planning snapshot | `product_id`, `demand_forecast_qty`, `supply_plan_qty` |
| `PromoActive` | Promo started | `promo_id`, `demand_multiplier` |
| `BlackSwanEventStarted` / `BlackSwanEventEnded` | Major disruption | `name`, `affected_countries`, `demand_multiplier` |

---

## Database (optional)

PostgreSQL is used by `run-service` for **resume** (current simulation time and tick count). Use your own schema and pipeline to load events from JSONL. See `.env.example` for DB credentials.

---

## Data Engineering Practice

You can use the event data for typical data engineering tasks:

- **Schema design:** Design a PostgreSQL (or other) schema from the JSON master data and event payloads; choose normalized vs denormalized structures and appropriate types and indexes.
- **Pipeline:** Parse the JSONL files in `data/events/` (each line is valid JSON) and load into your database; no quarantine step is needed.
- **Modeling:** Join events (e.g. `PurchaseOrderCreated` → `PurchaseOrderReceived` via `purchase_order_id`); build dimensional models for analytics.
- **Analytics:** Compute lead times, on-time delivery, inventory turns; analyze seasonality; build dashboards in PowerBI, Tableau, or Metabase.

---

## Example Workflows

**Batch: generate data and run a month of simulation**

```bash
python main.py generate --seed 42
python main.py simulate --ticks 720 --seed 42
```

**Historical backfill and 24/7 service**

```bash
python main.py generate --seed 42
python main.py generate-history --years 3 --seed 42
# Load data/events/history.jsonl into your database (optional)
python main.py run-service --tick-interval 5 --fresh
```

---

## Design and Implementation Notes

- **Event output:** `generate-history` writes a **single file** (`data/events/history.jsonl`) with no per-day rollover for speed. `simulate` and `run-service` write **date-partitioned** JSONL (one file per simulation day, `YYYY-MM-DD.jsonl`). Events are flushed on day rollover and on `save_state` (exit).
- **Black swan:** Major disruption events are included only when generating **3 years** of history; the event is placed in year 2 of the run.
- **Product and part IDs:** All event payloads use the 10 products (D-101..D-303) and 10 parts (P-001..P-010) defined by the generators.

---

## Legacy Version

The previous single-product (DRONE-X1) version of the simulator is preserved on the **`legacy`** branch. Use this repo’s **`main`** branch for the 10-drone, live-API scenario described above.
